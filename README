This is a utility for filtering a git branch.
It outputs a new branch with only the things we want included, in all revisions. It writes a new history preserving the part of it which is relevant for the new branch.
It resulted from the efforts to do the same thing using git filter-branch and then directly using git plumbing commands when git filter-branch was found to be too slow.
On my test repository with 100000 commits the original git filter-branch based filtering took around 2 days to finish one filter set. The same thing with git filter takes a minute on the same hardware.

The input is a positive list of files and directories to be included.

The tool can make several filterings simultaneously. This is normal, of course, where you want to
split a large git up into smaller ones and you want two or more disjoint sets of data which together
contain the whole original repository.

git_filter uses the topological sort to get the list of revisions to use and from that generates a linear history. This means that information about a commit with several parents will be lost, replaced by the commits themselves. I thought this was an OK compromise for simplicity and speed. You might not.
For simple projects with just one main branch and no merging git_filter will produce exactly the result you expect.

git_filter produces a lot of loose objects when it is finished so it is a very good idea to repack the repository when it is done: repack -ad, for example, before continuing working with the resultant repository.

In addition to tbe new bramches git_filter outputs a .revinfo text file per branch with a line per new revision showing correspondance to the original revisions. The purpose of this is to allow recreation of tag information.

The purpose of the git_filter program for me was to generate final repositories which contain none of the original commits. To do the I needed to do some further work. There are some scripts in the repository which assist me in this work but which may not be useful to you. First: striptags.py does what is says it strips the tag references from the original repository. I need to do this because even if I delete the original branch in the clone, the tags will still refer to it and prevent the cleanup.
striptags.py needs to be run *once* to remove all tags so when we clone and remove the origin and delete the other branches everything but the branch we are interested in will be removed and only objects from this branch are present.

The clean_git script produces a single clean repository with only the selected branch as it's master. It takes the source and destination git repositories as arguments.

create_clean_repos uses the clean_git script and the configuration file for git_filter to create a clean repository for each of the filtered branches generated by the git_filter run.

An example:

I have a git repository repo I want to split up. It is located in the current directory.
First I strip it of tags:

./striptags.py repo

Then run:

./git_filter git_filter.cfg && (cd repo && git repack -ad) && ./create_clean_repos git_filter.cfg


The Configuration File Syntax.

Look at the filter.cfg example, it is commented.

Configuration items and data:
The config file parser is very simple so a single space is the only allowed
separator. The parameter names should be exactly 4 characters followed by colon
and a space. Lines beginning with a # are comment lines and are ignored.

REPO: <repo> The configuration file should contain one REPO tag with the
             location of the repository to filter.

REVN: [range|ref] <refspec> A revision specification. Either a range e.g. master~1000..master or
                            a (branch) reference e.g. refs/heads/master.

BASE: <dir> a base directory for the filter file lists.

FILT: <name> <file> space separated name and filter file pair.

TPFX: <tag prefix> The prefix for tags and output repository names, prepended to the
                    filter set name.

